<html>
    <body>
        <canvas id="gamecanvas" width="272" height="272"></canvas>
        <script>
// nb: all coordinates are assumed to be tile-center coordinates!!

const canvas = document.getElementById("gamecanvas");
const ctx = canvas.getContext("2d");

// Screen dimensions in game tiles
const TILE_SIZE = 16;
const WIDTH = canvas.width / TILE_SIZE;
const HEIGHT = canvas.height / TILE_SIZE; 

const WORLD_WIDTH = 256;
const WORLD_HEIGHT = 256;

const KEYBIND_LEFT = "a";
const KEYBIND_RIGHT = "d";
const KEYBIND_UP = "w";
const KEYBIND_DOWN = "s";

// Maximum distance between camera, player on any axis
const CAMERA_MAX_DIST = 3;

// Tile types
const TILE = {
    Empty: 0,
    Wall: 1
};

// What tiles outside of the map (the "void") looks like
const VOID_TILE_TYPE = TILE.Wall;

// World (grid)
const world = new Array(WORLD_WIDTH);
for(let i = 0; i < WORLD_WIDTH; i++) {
    world[i] = new Array(WORLD_HEIGHT);
}

// Entities
const entities = [];

const player = {
    x: 0,
    y: 0,
    controls: {
        left: false,
        right: false,
        up: false,
        down: false
    }
};

// Camera
// (Does not necessarily have to be centered on player)
const camera = {
    x: 0,
    y: 0
};

// Event listener for key state change
const handleKeyEvent = function(key, state) {
    if(state) {

        let nextX = player.x;
        let nextY = player.y;
        if(key == KEYBIND_LEFT) {
            nextX--;
        } else if(key == KEYBIND_RIGHT) {
            nextX++;
        } else if(key == KEYBIND_UP) {
            nextY++;
        } else if(key == KEYBIND_DOWN) {
            nextY--;
        }

        // If the player can walk to that spot, go. 
        let canWalk = true;
        if(nextX < 0 || nextY < 0 || nextX == WORLD_WIDTH || nextY == WORLD_HEIGHT) {
            canWalk = false;
        } else {
            canWalk = canWalkOnto(world[nextX][nextY]);
        }

        if(canWalk) {
            player.x = nextX;
            player.y = nextY;
        }

        // Move camera if the player has moved too far from its move
        if(camera.x - player.x > CAMERA_MAX_DIST) {
            camera.x--;
        }

        if(camera.y - player.y > CAMERA_MAX_DIST) {
            camera.y--;
        }

        if(camera.x - player.x < -CAMERA_MAX_DIST) {
            camera.x++;
        }

        if(camera.y - player.y < -CAMERA_MAX_DIST) {
            camera.y++;
        }

    }
};

// Put player at random OK position
const placePlayer = function() {
    player.x = Math.floor(Math.random() * WORLD_WIDTH);
    player.y = Math.floor(Math.random() * WORLD_HEIGHT);
    camera.x = player.x;
    camera.y = player.y;
};

// Initialize
const init = function() {
    addEventListeners();
    generateWorld();
    placePlayer();
};

// Set up event listeners
const addEventListeners = function() {
    window.addEventListener("keydown", function(event) {handleKeyEvent(event.key, true)});
    window.addEventListener("keyup", function(event) {handleKeyEvent(event.key, false)});
};

// Generate world
const generateWorld = function() {

    // Temp: just generate checkerboard
    for(let x = 0; x < world.length; x++) {
        for(let y = 0; y < world[x].length; y++) {
            if(Math.random() > 0.9)
                world[x][y] = TILE.Wall;
            else
                world[x][y] = TILE.Empty;
        }
    }

};

// Check if tile can be walked on
const canWalkOnto = function(tile) {
    switch(tile) {
        case TILE.Empty: return true;
        case TILE.Wall: return false;
        default: console.log("warning: tile id " + tile + " isn't explicitly mapped in canWalk(), assuming it is solid!"); return false;
    }
};

// Step game
const step = function() {


};

// Tile to Color
const getTileColor = function(tile) {
    switch(tile) {
        case TILE.Empty: return "#000000";
        case TILE.Wall: return "#777777";
        default: console.log("warning: tile id " + tile + " isn't mapped in getTileColor(), assuming it is white!"); return "#ffffff";
    }
};

// Player to Color
const getPlayerColor = function() {
    return "#ff0000";
};

// Draw world
const drawWorld = function() {

    for(let x = 0; x < WIDTH; x++) {
        for(let y = 0; y < HEIGHT; y++) {
            
            // Move to middle of screen
            let worldX = x + camera.x -  (WIDTH - 1) / 2;
            let worldY = y + camera.y - (HEIGHT - 1) / 2;

            // Don't draw tiles outside of the map
            let tile;
            if(worldX < 0 || worldY < 0 || worldX >= WORLD_WIDTH || worldY >= WORLD_HEIGHT) {
                tile = VOID_TILE_TYPE;
            } else {
                // Draw tile (don't draw empties)
                tile = world[worldX][worldY];
            }
            if(tile != TILE.Empty) {
                ctx.fillStyle = getTileColor(tile);
                ctx.fillRect(x * TILE_SIZE, canvas.height - (y + 1) * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }

        }
    }

};

// Draw entities
const drawEntities = function() {

};

// Draw players
const drawPlayer = function() {

    let x = player.x + (WIDTH - 1) / 2 - camera.x;
    let y = player.y + (HEIGHT - 1) / 2 - camera.y;
    ctx.fillStyle = getPlayerColor();
    ctx.fillRect(x * TILE_SIZE, canvas.height - (y + 1) * TILE_SIZE, TILE_SIZE, TILE_SIZE);

};

// Main draw function
const draw = function() {

    // Draw background
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw bottom-most layer, world
    drawWorld();

    // Layer 2, entities
    drawEntities();

    // Top layer, player
    drawPlayer();

};

// Main game loop
const run = function() {
    draw();
    step();

    requestAnimationFrame(run);
};

const start = function() {
    init();
    run();
};

start();
        </script>
    </body>
</html>