<html>
    
    <head>
        <title>OBJ to JSON Mesh Tool</title>
        <style>
#drop-zone {
    background-color: #eeeeee;
    width: 800px;
    height: 500px;
}
        </style>
    </head>

    <body>

        <h1>OBJ to JSON mesh converter</h1>
        <div id="drop-zone"></div>
        <p>This tool converts Wavefront OBJ 3D files to JSON. That's all.</p>
        
        <script>
const dropZone = document.getElementById("drop-zone");

const convert = function(text) {
    
    let lines = text.split("\n");
    let lineNum = 0;

    let vertexes = [];
    let faces = [];

    console.log(lines);
    for(let line of lines) {
        
        lineNum++;
        line = line.trim().split(/\s+/);

        if(line.length == 0)
            continue;

        /* Skip comments. */
        if(line[0].charAt(0) == '#') {
            continue;
        }

        switch(line[0]) {
            case "v": {
                if(line.length < 4) {
                    alert("error on line " + lineNum + ": vertex has too few elements (must have at least 3)");
                    return false;
                }

                let x = parseFloat(line[1]);
                let y = parseFloat(line[2]);
                let z = parseFloat(line[3]);
                vertexes.push([x, y, z]);

                break;
            }
            case "f": {

                if(line.length < 4) {
                    alert("error on line " + lineNum + ": face has too few elements (must have at least 3)");
                }

                /* Assumes CCW point order */
                let base = parseInt(line[1]);
                for(let i = 2; i < line.length - 1; i++) {
                    
                    /*
                    let l1 = line[i].split("/");
                    let l2 = line[i].split("/");
                    */

                    let strIndex1 = line[i].indexOf("/");
                    let strIndex2 = line[i + 1].indexOf("/");
                    let f1 = parseInt(line[i].substring(0, strIndex1 < 0 ? line[i].length : strIndex1));
                    let f2 = parseInt(line[i + 1].substring(0, strIndex2 < 0 ? line[i].length : strIndex2));

                    faces.push([base, f1, f2]);
                }

                break;
            }
            case "vn": {

                break;
            }
            case "vt": {
                break;
            }
        }

    }

    /* go through faces, convert negative indices to positive */
    for(let face of faces) {
        for(let i = 0; i < face.length; i++) {
            face[i] = face[i] < 0 ? vertexes.length + face[i] : face[i];
        }
    }

    let resultObj = {
        faces: faces,
        vertices: vertexes
    };

    console.log(JSON.stringify(resultObj));

}

const handleDragOver = function(event) {
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = "copy";
};

const handleFileSelect = function(event) {
    event.stopPropagation();
    event.preventDefault();

    for(let file of event.dataTransfer.files) {
        
        let reader = new FileReader();
        reader.onload = function(file) {
            convert(file.target.result);
        }

        reader.readAsText(file);

    }
};

dropZone.addEventListener("dragover", handleDragOver);
dropZone.addEventListener("drop", handleFileSelect);
        </script>
    
    </body>

</html>