<html>
    
    <head>
        
        <title>CEC-16</title>
        
        <style>
body {
    width: 75%;
    margin-left: auto;
    margin-right: auto;
    font-family: Segoe UI, Helvetica, Arial, sans-serif;
}

h1 {
    font-size: 2.0em;
}

h2 {
    font-size: 1.5em;
}

h3 {
    font-size: 1.25em;
}

table {
    width: 100%;
    border-collapse: collapse;
}

table, th, td {
    border: 1px solid #888888;
}

th {
    padding: 0.7em;
    background-color: #f5f5f5;
}

td {
    padding: 0.3em;
}
        </style>

    </head>
    
    <body>

        <h1>CEC Instructions</h1>

        <p>The CEC instruction set is intentionally designed to be lightweight and flexible. Instead of implementing complex instructions in the CPU, programmers are encouraged to split them up into several fast instructions.</p>

        <table>
            <tr>
                <th width="5%">Opcode (6-bit)</th>
                <th width="5%">Mnemonic</th>
                <th width="15%">Operands</th>
                <th width="50%">Operation</th>
                <th>Notes</th>
            </tr>
            <tr>
                <th>0x00</th>
                <td>NOP</td>
                <td>None</td>
                <td>Nothing</td>
                <td></td>
            </tr>
            <tr>
                <th>0x01</th>
                <td>MOV</td>
                <td>Reg(X), Reg(Y)</td>
                <td>Puts value in register X into register Y.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x02</th>
                <td>MOV</td>
                <td>Imm(I), Reg(X)</td>
                <td>Puts immediate value I into register X.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x03</th>
                <td>LOAD</td>
                <td>Reg(X), Reg(Y)</td>
                <td>Puts value in memory location pointed to by register X into register Y.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x04</th>
                <td>STORE</td>
                <td>Reg(X), Reg(Y)</td>
                <td>Stores value in register X into memory location pointed to by register Y.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x05</th>
                <td>CMP</td>
                <td>Reg(X), Reg(Y)</td>
                <td>Compares the value in register X and the value in register Y. Sets flags accordingly.</td>
                <td>Similar to SUB: If X == Y the Zero Flag is set; otherwise, the Sign Flag is set to reflect (X - Y).</td>
            </tr>
            <tr>
                <th>0x06</th>
                <td>JMP</td>
                <td>Reg(X)</td>
                <td>Unconditional jump. Sets IP to the value in register X.</td>
                <td>Operation only exists for 16-bit operation size. Attempting to JMP to a 32-bit or 8-bit address will result in the CPU creating a Bad Instruction exception. This applies to all other jumps.</td>
            </tr>
            <tr>
                <th>0x07</th>
                <td>JMP</td>
                <td>Imm(I)</td>
                <td>Unconditional jump. Sets IP to the value of immediate I.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x08</th>
                <td>JG</td>
                <td>Reg(X)</td>
                <td>Conditional jump. Sets IP to the value in register X if the Sign Flag is positive (set) and the Zero Flag is not set.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x09</th>
                <td>JG</td>
                <td>Imm(I)</td>
                <td>Conditional jump. Immediate version of JG(Reg).</td>
                <td></td>
            </tr>
            <tr>
                <th>0x0A</th>
                <td>JL</td>
                <td>Reg(X)</td>
                <td>Conditional jump. Sets IP to the value in register X if the Sign Flag is negative (not set) and the Zero Flag is not set.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x0B</th>
                <td>JL</td>
                <td>Imm(I)</td>
                <td>Conditional jump. Immediate version of JL(Reg)</td>
                <td></td>
            </tr>
            <tr>
                <th>0x0C</th>
                <td>JE</td>
                <td>Reg(X)</td>
                <td>Conditional jump. Sets IP to the value in register X if the Zero Flag is set.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x0D</th>
                <td>JE</td>
                <td>Imm(I)</td>
                <td>Conditional jump. Immediate version of JE(Reg)</td>
                <td></td>
            </tr>
            <tr>
                <th>0x0E</th>
                <td>JNE</td>
                <td>Reg(X)</td>
                <td>Conditional jump. Sets IP to value in register X if the Zero Flag is not set.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x0F</th>
                <td>JNE</td>
                <td>Imm(X)</td>
                <td>Conditional jump. Immediate version of JNE(Reg)</td>
                <td></td>
            </tr>
            <tr>
                <th>0x10</th>
                <td>CALL</td>
                <td>Reg(X)</td>
                <td>Pushes IP to the stack (see PUSH) and sets IP to the value in register X.</td>
                <td>Subject to same 16-bit limitation as the jump instructions (see JMP(Reg)). This also applies for CALL(Imm).</td>
            </tr>
            <tr>
                <th>0x11</th>
                <td>CALL</td>
                <td>Imm(I)</td>
                <td>Immediate version of CALL(Reg)</td>
                <td></td>
            </tr>
            <tr>
                <th>0x12</th>
                <td>RET</td>
                <td>Reg(X)</td>
                <td>Pops 16-bit value from the stack (see POP(Reg)) into IP.</td>
                <td>Disregards operation size since it has no operands.</td>
            </tr>
            <tr>
                <th>0x13</th>
                <td>PUSH</td>
                <td>Reg(X)</td>
                <td>Subtracts the size of the operation from SP, and stores the value in register X in memory at the location pointed to by the new SP.</td>
                <td>Not aware of stack alignment and padding. The programmer must keep track of what data is on the stack at all times.</td>
            </tr>
            <tr>
                <th>0x14</th>
                <td>PUSH</td>
                <td>Imm(I)</td>
                <td>Immediate version of PUSH(Reg).</td>
                <td></td>
            </tr>
            <tr>
                <th>0x15</th>
                <td>POP</td>
                <td>Reg(X)</td>
                <td>Stores the value in memory at the location pointed to by SP into register X, and adds the size of the operation to SP.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x16</th>
                <td>AND</td>
                <td>Reg(X), Reg(Y), Reg(Z)</td>
                <td>Stores the bitwise AND of the values in register X and Y into register Z.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x17</th>
                <td>OR</td>
                <td>Reg(X), Reg(Y), Reg(Z)</td>
                <td>Stores the bitwise OR of the values in register X and Y into register Z.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x18</th>
                <td>NOT</td>
                <td>Reg(X), Reg(Y)</td>
                <td>Stores the bitwise NOT of the value in register X into register Y.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x19</th>
                <td>XOR</td>
                <td>Reg(X), Reg(Y), Reg(Z)</td>
                <td>Stores the bitwise XOR of the values in register X and register Y into register Z.</td>
                <td></td>
            </tr>
            <tr>
                <th>0x1A</th>
                <td>LSR</td>
                <td>Reg(X), Reg(Y), Reg(Z)</td>
                <td>Stores the value in register X logically shifted right by Y bits into register Z.</td>
                <td>Does not preserve sign bit.</td>
            </tr>
            <tr>
                <th>0x1B</th>
                <td>LSR</td>
                <td>Reg(X), Imm(I), Reg(Y)</td>
                <td>Stores the value in register X logically shifted right by I bits into register Y.</td>
                <td>Does not preserve sign bit.</td>
            </tr>
            <tr>
                <th>0x1C</th>
                <td>LSL</td>
                <td>Reg(X), Reg(Y), Reg(Z)</td>
                <td>Same as LSR(Reg,Reg,Reg), but shifts left.</td>
                <td>Does not preserve sign bit.</td>
            </tr>
            <tr>
                <th>0x1D</th>
                <td>LSL</td>
                <td>Reg(X), Imm(I), Reg(Y)</td>
                <td>Same as LSR(Reg,Imm,Reg) but shifts right.</td>
                <td>Does not preserve sign bit.</td>
            </tr>
        </table>

    </body>

</html>